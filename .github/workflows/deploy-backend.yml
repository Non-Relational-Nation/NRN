name: Deploy Backend to AWS

on:
  push:
    branches: [ main, infrastructure ]  # Added infrastructure branch for testing
    paths: [ 'backend/**' ]
  workflow_dispatch:

env:
  AWS_REGION: af-south-1

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    
    # Add OIDC permissions
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
        cache: 'npm'
        cache-dependency-path: backend/package-lock.json

    - name: Install dependencies
      working-directory: ./backend
      run: npm ci

    - name: Type check application (skip for now - using tsx runtime)
      working-directory: ./backend
      run: echo "Skipping type check - using tsx runtime deployment"

    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: github-actions-backend-deploy
        aws-region: ${{ env.AWS_REGION }}

    - name: Get API server IP
      id: get-api-ip
      run: |
        echo "Looking for API server instance..."
        API_IP=$(aws ec2 describe-instances \
          --region ${{ env.AWS_REGION }} \
          --filters "Name=tag:Name,Values=nrn-api-grad-group01-dev" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        if [ "$API_IP" = "None" ] || [ -z "$API_IP" ]; then
          echo "ERROR: No running API instance found!"
          echo "Checking all instances..."
          aws ec2 describe-instances \
            --region ${{ env.AWS_REGION }} \
            --filters "Name=tag:Name,Values=nrn-api-grad-group01-dev" \
            --query 'Reservations[].Instances[].[InstanceId,State.Name,PublicIpAddress]' \
            --output table
          exit 1
        fi
        
        echo "Found API server at: $API_IP"
        
        # Debug: Check what key pair is assigned to the instance
        echo "=== Checking instance key pair ==="
        INSTANCE_ID=$(aws ec2 describe-instances \
          --region ${{ env.AWS_REGION }} \
          --filters "Name=tag:Name,Values=nrn-api-grad-group01-dev" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        
        KEY_NAME=$(aws ec2 describe-instances \
          --region ${{ env.AWS_REGION }} \
          --instance-ids $INSTANCE_ID \
          --query 'Reservations[0].Instances[0].KeyName' \
          --output text)
        
        echo "Instance ID: $INSTANCE_ID"
        echo "Key pair name: $KEY_NAME"
        
        echo "api_ip=$API_IP" >> $GITHUB_OUTPUT

    - name: Deploy to API server
      env:
        API_IP: ${{ steps.get-api-ip.outputs.api_ip }}
      run: |
        # Create deployment package
        tar -czf backend-deploy.tar.gz -C backend .
        
        # Setup SSH with new clean approach
        echo "${{ secrets.TEAM_SSH_KEY }}" > team-key
        chmod 600 team-key
        
        # Fix potential line ending issues
        sed -i 's/\r$//' team-key
        
        # Test connection before proceeding
        echo "Testing SSH connection..."
        ssh -i team-key -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@$API_IP "echo 'Connection successful'"
        
        # Copy files to server
        echo "Copying deployment package to server..."
        scp -i team-key -o StrictHostKeyChecking=no backend-deploy.tar.gz ubuntu@$API_IP:/home/ubuntu/
        
        # Deploy on server
        ssh -i team-key -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ServerAliveCountMax=3 ubuntu@$API_IP << 'EOF'
          set -e  # Exit on any error
          
          # Stop existing application - nuclear cleanup (ensure all commands succeed)
          sudo pkill -9 -f "node" || echo "No node processes to kill"
          sudo pkill -9 -f "tsx" || echo "No tsx processes to kill"
          sudo pkill -9 -f "pm2" || echo "No pm2 processes to kill"
          sudo killall node || echo "No node processes to killall"
          sudo killall tsx || echo "No tsx processes to killall"
          pm2 kill || echo "PM2 already clean"
          sleep 5
          
          # Free up port 3001 specifically
          sudo fuser -k 3001/tcp || echo "Port 3001 already free"
          sudo netstat -tlnp | grep :3001 | awk '{print $7}' | cut -d/ -f1 | xargs -r sudo kill -9 || echo "No processes on port 3001"
          sleep 2
          
          # Install Node.js 22 (Ubuntu 22.04)
          echo "Setting up Node.js 22 on Ubuntu 22.04..."
          
          # Fix any broken package installations first
          echo "🔧 Fixing package manager state..."
          sudo dpkg --configure -a || echo "dpkg configure completed"
          sudo apt-get update --fix-missing || echo "apt update completed"
          sudo apt-get install -f -y || echo "apt install fix completed"
          
          # Install Node.js 22 from NodeSource (Ubuntu compatible)
          curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
          sudo apt-get install -y nodejs
          
          # Verify installation
          echo "Node.js version: $(node --version)"
          echo "NPM version: $(npm --version)"
          
          # Extract new code - clean deployment
          sudo rm -rf /home/ubuntu/app/backend || true
          sudo mkdir -p /home/ubuntu/app/backend
          sudo tar -xzf /home/ubuntu/backend-deploy.tar.gz -C /home/ubuntu/app/backend
          cd /home/ubuntu/app/backend
          sudo chown -R ubuntu:ubuntu /home/ubuntu/app/backend
          
          # Install dependencies
          echo "Installing dependencies..."
          npm ci || npm install
          
          # Install tsx globally for runtime
          echo "Installing tsx globally..."
          sudo npm install -g tsx@latest
          
          # Create environment file in correct location
          echo "Creating environment configuration..."
          echo "NODE_ENV=production" > .env
          echo "PORT=3001" >> .env
          echo "HOST=0.0.0.0" >> .env
          echo "FRONTEND_URL=https://dikiudmyn4guv.cloudfront.net" >> .env
          echo "MONGODB_HOST=localhost" >> .env
          echo "MONGODB_PORT=27017" >> .env
          echo "MONGODB_DATABASE=nrn_db" >> .env
          echo "REDIS_HOST=localhost" >> .env
          echo "REDIS_PORT=6379" >> .env
          echo "NEO4J_URI=bolt://localhost:7687" >> .env
          echo "S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}" >> .env
          echo "AWS_S3_BUCKET=${{ secrets.S3_BUCKET_NAME }}" >> .env
          echo "AWS_REGION=${{ env.AWS_REGION }}" >> .env 
          echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> .env
          echo "GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}" >> .env
          echo "GOOGLE_REDIRECT_URL=https://dikiudmyn4guv.cloudfront.net/login/callback" >> .env
          
          # Stop any existing PM2 processes
          pm2 kill || echo "PM2 already clean"
          sudo pkill -9 -f "node" || echo "No node processes to kill"
          
          # Stop the systemd service if running
          sudo systemctl stop nrn-backend || echo "Service already stopped"
          
          # Update systemd service to use tsx
          echo "Updating systemd service configuration..."
          cat > nrn-backend.service << 'SERVICEEOF'
[Unit]
Description=NRN Backend Service
After=network.target

[Service]
Type=simple
User=ubuntu
WorkingDirectory=/home/ubuntu/app/backend
Environment=NODE_ENV=production
EnvironmentFile=/home/ubuntu/app/backend/.env
ExecStart=/usr/bin/npx tsx src/server.ts
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
SERVICEEOF
          sudo mv nrn-backend.service /etc/systemd/system/
          
          # Reload systemd daemon to pick up service changes
          sudo systemctl daemon-reload
          
          # Start the systemd service
          echo "Starting NRN backend service..."
          sudo systemctl start nrn-backend
          sudo systemctl enable nrn-backend
          
          # Wait a moment for service to start
          sleep 5
          
          # Check service status
          echo "=== Service Status ==="
          sudo systemctl status nrn-backend --no-pager
          
          # Check if service is active
          if sudo systemctl is-active --quiet nrn-backend; then
            echo "✅ Backend service is running successfully"
          else
            echo "❌ Backend service failed to start"
            echo "=== Recent logs ==="
            sudo journalctl -u nrn-backend -n 20 --no-pager
            exit 1
          fi
          
          echo "✅ Backend deployment completed successfully"
          echo "🎯 Workflow finishing now..."
        EOF