name: Deploy Backend to AWS

on:
  push:
    branches: [ main, infrastructure ]  # Added infrastructure branch for testing
    paths: [ 'backend/**' ]
  workflow_dispatch:

env:
  AWS_REGION: af-south-1

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    
    # Add OIDC permissions
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: backend/package-lock.json

    - name: Install dependencies
      working-directory: ./backend
      run: npm ci

    - name: Type check application
      working-directory: ./backend
      run: npx tsc --noEmit

    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: github-actions-backend-deploy
        aws-region: ${{ env.AWS_REGION }}

    - name: Get API server IP
      id: get-api-ip
      run: |
        API_IP=$(aws ec2 describe-instances \
          --region ${{ env.AWS_REGION }} \
          --filters "Name=tag:Name,Values=nrn-api-grad-group01-dev" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        echo "api_ip=$API_IP" >> $GITHUB_OUTPUT

    - name: Deploy to API server
      env:
        API_IP: ${{ steps.get-api-ip.outputs.api_ip }}
      run: |
        # Create deployment package
        tar -czf backend-deploy.tar.gz -C backend .
        
        # Setup SSH
        echo "${{ secrets.TEAM_SSH_KEY }}" > team-key
        chmod 600 team-key
        
        # Copy files to server
        scp -i team-key -o StrictHostKeyChecking=no backend-deploy.tar.gz ec2-user@$API_IP:/home/ec2-user/
        
        # Deploy on server
        ssh -i team-key -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ServerAliveCountMax=3 ec2-user@$API_IP << 'EOF'
          set -e  # Exit on any error
          
          # Stop existing application
          sudo pkill -f "node.*app" || true
          pm2 stop backend || true
          pm2 delete backend || true
          
          # Install Node.js 18 (Amazon Linux 2023 has compatible GLIBC)
          echo "Setting up Node.js 18 on Amazon Linux 2023..."
          
          # Install Node.js 18 from NodeSource (AL2023 compatible)
          curl -fsSL https://rpm.nodesource.com/setup_18.x | sudo bash -
          sudo yum install -y nodejs
          
          # Verify installation
          echo "Node.js version: $(node --version)"
          echo "NPM version: $(npm --version)"
          
          # Extract new code
          rm -rf /home/ec2-user/backend
          mkdir -p /home/ec2-user/backend
          tar -xzf /home/ec2-user/backend-deploy.tar.gz -C /home/ec2-user/backend
          cd /home/ec2-user/backend
          
          # Install dependencies
          echo "Installing dependencies..."
          npm ci || npm install
          
          # Create environment file
          echo "Creating environment configuration..."
          echo "NODE_ENV=production" > .env
          echo "PORT=5000" >> .env
          echo "HOST=0.0.0.0" >> .env
          echo "MONGODB_URI=${{ secrets.MONGODB_CONNECTION_STRING }}" >> .env
          echo "S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}" >> .env
          echo "AWS_REGION=${{ env.AWS_REGION }}" >> .env
          echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> .env
          
          # Install PM2 globally
          sudo npm install -g pm2@latest
          
          # Create logs directory
          mkdir -p logs
          
          # Start application with PM2 - try multiple approaches for compatibility
          if ! pm2 start "npx tsx src/server.ts" --name "backend" --env production; then
            echo "First PM2 approach failed, trying alternative..."
            # Alternative approach: create a simple start script
            echo '#!/bin/bash' > start.sh
            echo 'cd /home/ec2-user/backend' >> start.sh
            echo 'exec npx tsx src/server.ts' >> start.sh
            chmod +x start.sh
            pm2 start ./start.sh --name "backend" --env production
          fi
          
          pm2 save
          
          # Setup PM2 startup script
          sudo pm2 startup systemd -u ec2-user --hp /home/ec2-user || true
          
          # Show PM2 status and logs for debugging
          echo "=== PM2 Status ==="
          pm2 status
          echo "=== PM2 Logs ==="
          pm2 logs backend --lines 10 || true
          
          echo "‚úÖ Backend deployment completed successfully"
        EOF

    - name: Health check
      env:
        API_IP: ${{ steps.get-api-ip.outputs.api_ip }}
      run: |
        # Wait for application to start and database to connect
        echo "‚è≥ Waiting for application to start and database to connect..."
        sleep 45
        
        # Try health check endpoint multiple times
        for i in {1..6}; do
          echo "üîç Health check attempt $i/6 for http://$API_IP:5000/health"
          
          RESPONSE=$(curl -f -m 15 -w "\nHTTP_CODE:%{http_code}" http://$API_IP:5000/health 2>&1)
          CURL_EXIT=$?
          
          if [ $CURL_EXIT -eq 0 ]; then
            echo "‚úÖ Health check response:"
            echo "$RESPONSE"
            
            # Check if response indicates healthy or acceptable status
            if echo "$RESPONSE" | grep -q '"status":"OK"' || echo "$RESPONSE" | grep -q '"status":"DEGRADED"'; then
              echo "‚úÖ Backend deployed successfully!"
              exit 0
            fi
          else
            echo "‚ùå Health check failed with curl exit code: $CURL_EXIT"
            echo "Response: $RESPONSE"
          fi
          
          if [ $i -lt 6 ]; then
            echo "‚è≥ Retrying in 15 seconds..."
            sleep 15
          fi
        done
        
        echo "üö® Health check failed after 6 attempts. Checking server logs..."
        # SSH back to server to check logs
        ssh -i team-key -o StrictHostKeyChecking=no ec2-user@$API_IP << 'EOF'
          echo "=== PM2 Status ==="
          pm2 status
          echo "=== PM2 Logs ==="
          pm2 logs backend --lines 30
          echo "=== System Resources ==="
          free -h
          echo "=== Network Status ==="
          netstat -tlnp | grep :5000 || ss -tlnp | grep :5000 || echo "No process on port 5000"
        EOF
        exit 1